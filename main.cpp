//Streams for input/output
#include <fstream>
#include <sstream>
#include <iostream>

//Datatypes
#include <vector> 
#include <string>

//Global variables for saving the sequences of A, b and coefficients generated by the elimination
std::vector<std::vector<std::vector<double>>> As {};
std::vector<std::vector<<double>> bs {};
std::vector<std::vector<std::vector<double>>> Coeffs {};

/*
Converts a matrix (vector of vectors of doubles) into a String
*/
std::string to_str(std::vector<std::vector<double>> A)
{
	std::string result {};	
	for (int i=0; i<A.size(); i++){
		for (int j=0; j<A.at(i).size(); j++){
			result += std::to_string(A.at(i).at(j));
			result += " ";
		}
		result += "\n";
	}
	return result;
}

/*
Reads in a file in the format specified in the exercise,
writes matrix A and vector b as first entries to the global variables As and bs.
Returns an integer SUCCESS.
*/
int read_LP(std::string filename)
{
	std::ifstream infile(filename);
	std::string line;
	
	if (!infile){
	cerr << "Could not read file "+filename;
	return -1;
	}

	std::getline(infile, line);
	std::istringstream iss(line);
	int m, n;
	iss >> m >> n;

	std::getline(infile, line); //ToDo: maybe omit the following lines because c is not used
	std::istringstream iss(line);
	std::vector<double> c;
	double d;
	while(iss >> d) b.push_back(c);

	std::getline(infile, line);
	std::istringstream iss(line);
	std::vector<double> b;
	double d;
	while(iss >> d) b.push_back(d);

	std::vector<std::vector<double>> A;
	while (std::getline(infile, line){
		std::istringstream iss(line);
		std::vector<double> a;
		double d;
		while(iss >> d) a.push_back(d);
		A.push_back(a);	
	}
	//ToDo: verify that A is indeed an mxn-matrix

	bs.push_back(b);
	As.push_back(A);
	return 0;
}

/* Outline for Fourier-Motzkin step

Compute index sets U, L, N (how?)
initialize new matrix A and new vector b and new (coefficient) matrix C
 for (auto i : L){
	for (auto j : U){
		//The rows i and j form a pair of upper/lower bound
		// Now we have to generate the new inequality
		std::vector<double> new_row {};
		std::vector<double> coefficient_row(A.size(), 0.0);
		for (int k=0; k!=A[i].size(); ++k){
			new_row.push_back(A[i][k]/A[i][0] + A[j][k]/A[j][0]);
			coefficient_row[i]=1/A[i][0];
			coefficient_row[j]=1/A[j][0];
		}
		A.push_back(new_row);
		b.push_back(b[i]/A[i][0] + b[j]/A[j][0]);
		C.push_back(coefficient_row);
	}
 }
*/

/* Outline for Fourier-Motzkin elimination

create lists/vectors of A's, b's and coefficient matrices C
while(As.last().at(1).size() >1){
	A_new, b_new, C_new = FourierMotzkinStep(As.last(), bs.last())
	append A_new, b_new, C_new to respective list
}
//Check if there exists a solution, if not, remember the first wrong inequality 
int no_solution_at {As.last().size()}; //correct syntax?
for (int i=0, i!=As.last().size(), ++i){
	if (As.last().at(1).at(i) > bs.last().at(i)){
		no_solution_at=i;
		break;
	}
}
if (no_solution_at == As.last().size()){
	//Calculate a solution
}
else{
	//Calculate the certificate
}
*/

int main()
{	
	std::vector<std::vector<double>> A{
	{1,3.5,2},
	{4,2,1.6},
	{5.3,7,1},
	{4.4,7,3},
	{2.5,3,1}
	};
	std::cout << to_str(A);
}


