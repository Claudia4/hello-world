//Streams for input/output
#include <fstream>
#include <sstream>
#include <iostream>

//Datatypes
#include <vector> 
#include <string>
#include <utility> //std::pair


//Global variables for saving the sequences of A, b and coefficients generated by the elimination
std::vector<std::vector<std::vector<double>>> As {};
std::vector<std::vector<double>> bs {};
std::vector<std::vector<std::vector<double>>> Coeffs {};

//Helper functions
/*
Convert a matrix (vector of vectors of doubles) into a String
*/
std::string to_str(std::vector<std::vector<double>> A)
{
	std::string result {};	
	for (int i=0; i<A.size(); i++){
		for (int j=0; j<A.at(i).size(); j++){
			result += std::to_string(A.at(i).at(j));
			result += " ";
		}
		result += "\n";
	}
	return result;
}
/*
Convert a vector of doubles into a String
*/
std::string to_str(std::vector<double> b)
{
	std::string result {};	
	for (int i=0; i<b.size(); i++){
		result += std::to_string(b.at(i));
		result += " ";
	}
	return result;
}

/*
Reads in a file in the format specified in the exercise,
writes matrix A and vector b as first entries to the global variables As and bs.
Returns an integer SUCCESS.
*/
int read_LP(std::string filename)
{
	std::ifstream infile(filename);
	std::string line;
	
	if (!infile){
	std::cerr << "Could not read file "+filename;
	return EXIT_FAILURE;
	}

	std::getline(infile, line);
	std::istringstream iss(line);
	int m, n;
	iss >> m >> n;

	std::getline(infile, line); //ToDo: maybe omit the following lines because c is not used
	iss.str (line);
	iss.clear();
	std::vector<double> c;
	double d;
	while(iss >> d)	c.push_back(d);

	std::getline(infile, line);
	iss.str (line);
	iss.clear();
	std::vector<double> b;
	while(iss >> d) b.push_back(d);

	std::vector<std::vector<double>> A;
	while (std::getline(infile, line)){
		iss.str (line);
		iss.clear();
		std::vector<double> a;
		while(iss >> d) a.push_back(d);
		A.push_back(a);	
	}
	//ToDo: verify that A is indeed an mxn-matrix

	bs.push_back(b);
	As.push_back(A);
	return EXIT_SUCCESS;
}


/*
Applies one Fourier-Motzkin-elemination step to the last Elements of As and bs
(in order to eliminate the first variable of the system Ax <= b)
and writes the result as new last elements of As and bs,
stores the coefficients used to generate the new inequalities as last element of Coeffs
*/
void fourier_motzkin_step()
{
	//Compute index sets U, L, N for upper bounds/lower bounds/first variable not used
	std::vector<int> U {};
	std::vector<int> L {};
	std::vector<int> N {};
	for (int i=0; i<As.back().size(); i++) {
		if (As.back().at(i).at(0) < 0.0) L.push_back(i);
		else if (As.back().at(i).at(0) == 0.0) N.push_back(i);
		else U.push_back(i); 
	}

	std::vector<std::vector<double>> new_A {};
	std::vector<double> new_b {};
	std::vector<std::vector<double>> C {};

	for (auto i : L){
		for (auto j : U){
			//The rows i and j form a pair of upper/lower bound
			// Now we have to generate the new inequality
			std::vector<double> new_row {};
			std::vector<double> coefficient_row(As.back().size(), 0.0);
			for (int k=1; k<As.back().at(i).size(); k++){
				new_row.push_back(As.back().at(i).at(k)/As.back().at(i).at(0) + As.back().at(j).at(k)/As.back().at(j).at(0));
				coefficient_row[i]=1/As.back().at(i).at(0);
				coefficient_row[j]=1/As.back().at(j).at(0);
			}
			new_A.push_back(new_row);
			new_b.push_back(bs.back().at(i)/As.back().at(i).at(0) + bs.back().at(j)/As.back().at(j).at(0));
			C.push_back(coefficient_row);
		}
	}
	for (auto i : N){
		//Copy the inequalities where x_1 doesn't occur
		std::vector<double> new_row {};
		std::vector<double> coefficient_row(As.back().size(), 0.0);
		for (int k=1; k<As.back().at(i).size(); k++){
			new_row.push_back(As.back().at(i).at(k));
			coefficient_row[i]=1.0;
		}
		new_A.push_back(new_row);
		new_b.push_back(bs.back().at(i));
		C.push_back(coefficient_row);
	}
	//Store the results
	As.push_back(new_A);
	bs.push_back(new_b);
	Coeffs.push_back(C);
}


std::pair <bool, std::vector<double>> fourier_motzkin_elimination()
{
	//Apply elimination steps until only one variable remains
	while(As.back().at(1).size() >1) fourier_motzkin_step();
	//Apply one last elimination step
	fourier_motzkin_step();

	//Check if there exists a solution, if not, remember the first wrong inequality 
	bool has_solution {true};
	int no_solution_at {};
	for (int i=0; i<As.back().size(); i++){
		if (As.back().at(1).at(i) > bs.back().at(i)){
			has_solution = false;
			no_solution_at=i;
			break;
		}
	}
	if (has_solution){
		//Calculate a solution
		std::vector<double> solution {};
		
		std::pair <bool, std::vector<double>> result (has_solution, solution);
		return result;
	}
	else{
		//Calculate the certificate for infeasibility
		std::vector<double> certificate {};

		std::pair <bool, std::vector<double>> result (has_solution, certificate);
		return result;
	}
}


int main(int argc, const char *argv[])
{
	//read in the LP
	if (argc < 2){
		std::cerr << "Usage: " << argv[0] << " <lp filename> /n";
		return EXIT_FAILURE;
	}
	int success;
	success = read_LP(argv[1]);
	std::cout << "I read the following problem:\n";
	std::cout << to_str(bs.at(0));
	std::cout << "\n";
	std::cout << to_str(As.at(0));

	//do the Fourier-Motzkin-eleminiation
	fourier_motzkin_step();
	std::cout << "After one step we get\n";
	std::cout << to_str(bs.back());
	std::cout << "\n";
	std::cout << to_str(As.back());

	//print the result
	
}



/* Old main function
int main()
{	
	std::vector<std::vector<double>> A{
	{1,3.5,2},
	{4,2,1.6},
	{5.3,7,1},
	{4.4,7,3},
	{2.5,3,1}
	};
	std::cout << to_str(A);
}
*/
