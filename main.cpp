//Streams for input/output
#include <fstream>
#include <sstream>
#include <iostream>

//Datatypes
#include <vector> 
#include <string>
#include <utility> //std::pair

#include <limits>

//Global variables for saving the sequences of A, b and coefficients generated by the elimination
std::vector<std::vector<std::vector<double>>> As {};
std::vector<std::vector<double>> bs {};
std::vector<std::vector<std::vector<double>>> Coeffs {};
std::vector<std::vector<int>> Ls {};

//Helper functions
/*
Convert a matrix (vector of vectors of doubles) into a String
*/
std::string to_str(std::vector<std::vector<double>> A)
{
	std::string result {};	
	for (int i=0; i<A.size(); i++){
		for (int j=0; j<A.at(i).size(); j++){
			result += std::to_string(A.at(i).at(j));
			result += " ";
		}
		result += "\n";
	}
	return result;
}
/*
Convert a vector of doubles into a String
*/
std::string to_str(std::vector<double> b)
{
	std::string result {};	
	for (int i=0; i<b.size(); i++){
		result += std::to_string(b.at(i));
		result += " ";
	}
	return result;
}

/*
Reads in a file in the format specified in the exercise,
writes matrix A and vector b as first entries to the global variables As and bs.
Returns an integer SUCCESS.
*/
int read_LP(std::string filename)
{
	std::ifstream infile(filename);
	std::string line;
	
	if (!infile){
	std::cerr << "Could not read file "+filename;
	return EXIT_FAILURE;
	}

	std::getline(infile, line);
	std::istringstream iss(line);
	int m, n;
	iss >> m >> n;

	std::getline(infile, line); //ToDo: maybe omit the following lines because c is not used
	iss.str (line);
	iss.clear();
	std::vector<double> c;
	double d;
	while(iss >> d)	c.push_back(d);

	std::getline(infile, line);
	iss.str (line);
	iss.clear();
	std::vector<double> b;
	while(iss >> d) b.push_back(d);

	std::vector<std::vector<double>> A;
	while (std::getline(infile, line)){
		iss.str (line);
		iss.clear();
		std::vector<double> a;
		while(iss >> d) a.push_back(d);
		A.push_back(a);	
	}
	//ToDo: verify that A is indeed an mxn-matrix

	bs.push_back(b);
	As.push_back(A);
	return EXIT_SUCCESS;
}


/*
Applies one Fourier-Motzkin-elemination step to the last Elements of As and bs
(in order to eliminate the first variable of the system Ax <= b)
and writes the result as new last elements of As and bs,
stores the coefficients used to generate the new inequalities as last element of Coeffs
*/
void fourier_motzkin_step()
{
	//Compute index sets U, L, N for upper bounds/lower bounds/first variable not used
	std::vector<int> U {};
	std::vector<int> L {};
	std::vector<int> N {};
	for (int i=0; i<As.back().size(); i++) {
		if (As.back().at(i).at(0) < 0.0) L.push_back(i);
		else if (As.back().at(i).at(0) == 0.0) N.push_back(i);
		else U.push_back(i); 
	}
	Ls.push_back(L);

	std::vector<std::vector<double>> new_A {};
	std::vector<double> new_b {};
	std::vector<std::vector<double>> C {};

	for (auto i : L){
		for (auto j : U){
			//The rows i and j form a pair of upper/lower bound
			// Now we have to generate the new inequality
			std::vector<double> new_row {};
			std::vector<double> coefficient_row(As.back().size(), 0.0);
			for (int k=1; k<As.back().at(i).size(); k++){
				new_row.push_back(As.back().at(i).at(k)/As.back().at(i).at(0) + As.back().at(j).at(k)/As.back().at(j).at(0));
				coefficient_row[i]=1/As.back().at(i).at(0);
				coefficient_row[j]=1/As.back().at(j).at(0);
			}
			new_A.push_back(new_row);
			new_b.push_back(bs.back().at(i)/As.back().at(i).at(0) + bs.back().at(j)/As.back().at(j).at(0));
			C.push_back(coefficient_row);
		}
	}
	for (auto i : N){
		//Copy the inequalities where x_1 doesn't occur
		std::vector<double> new_row {};
		std::vector<double> coefficient_row(As.back().size(), 0.0);
		for (int k=1; k<As.back().at(i).size(); k++){
			new_row.push_back(As.back().at(i).at(k));
			coefficient_row[i]=1.0;
		}
		new_A.push_back(new_row);
		new_b.push_back(bs.back().at(i));
		C.push_back(coefficient_row);
	}
	//Store the results
	As.push_back(new_A);
	bs.push_back(new_b);
	Coeffs.push_back(C);
}

/*
Fourier-Motzkin-elimination-algorithm
Applies Fourier-Motzkin-elimination-steps until the system has no variables any more
decides wether there is a solution to the system (based on the resulting inequalities)
Calculates such a solution or
gives a certificate for the infeasibility.
Return: pair of bool has_solution and solution vector/certificate vector
*/
std::pair <bool, std::vector<double>> fourier_motzkin_elimination()
{
	//Apply elimination steps until only one variable remains
	while(As.back().at(1).size() >1) fourier_motzkin_step();
	//Apply one last elimination step
	fourier_motzkin_step();

	//Check if there exists a solution, if not, remember the first wrong inequality 
	bool has_solution {true};
	int no_solution_at {};
	for (int i=0; i<As.back().size(); i++){
		if (As.back().at(1).at(i) > bs.back().at(i)){
			has_solution = false;
			no_solution_at=i;
			break;
		}
	}
	if (has_solution){
		//Calculate a solution
		//as suggested in the lecture, by always choosing the biggest lower bound
		std::vector<double> solution {};
		double xn = As.back().at(0).at(0);
		for (int i=1; i<As.back().size(); i++){
			if (As.back().at(i).at(0) > xn) xn=As.back().at(i).at(0);
		}
		solution.push_back(xn);
		
		double new_val;
		double current_max;
		for (int i=As.at(0).at(0).size()-1; i>0; i++){
			current_max = std::numeric_limits<double>::lowest();
			for (auto k : Ls.at(i-1)){
				new_val = -bs.at(i).at(k);
				for (int l=1; l<=solution.size(); l++){
					new_val += As.at(i).at(k).at(As.at(i).at(k).size()-l)*solution.at(solution.size()-l);
				}
				if (new_val>current_max){
					current_max = new_val;
				}
			}
			solution.insert(solution.begin(), current_max);
		}
		
		std::pair <bool, std::vector<double>> result (has_solution, solution);
		return result;
	}
	else{
		//Calculate the certificate for infeasibility
		//Denote in pairs the index of the considered line and its coefficient in the linear combination of the infeasible row
		std::pair<double, int> first (1.0, no_solution_at);
		std::vector<std::pair<double, int>> combi {first};
		std::vector<std::pair<double, int>> new_combi {};

		//follow up backwards in the coefficient matrices which lines where used with which factors
		for(int i=Coeffs.size()-1; i>=0; i--){
			for (auto pair : combi){
				for (int k=0; k<Coeffs.at(i).at(pair.second).size(); k++){
					double entry = Coeffs.at(i).at(pair.second).at(k);
					if(entry != 0.0){
						new_combi.push_back(std::pair<double,int> (pair.first * entry, k));
					}
				}
			}
			combi = new_combi;
			new_combi.clear();
		}

		std::vector<double> certificate (As.at(0).size(), 0.0);
		for (auto pair : combi){
			certificate.at(pair.second) += pair.first;
		}
		
		return std::pair <bool, std::vector<double>> (has_solution, certificate);
	}
}


int main(int argc, const char *argv[])
{
	//read in the LP
	if (argc < 2){
		std::cerr << "Usage: " << argv[0] << " <lp filename> /n";
		return EXIT_FAILURE;
	}
	int success;
	success = read_LP(argv[1]);
	std::cout << "I read the following problem:\n";
	std::cout << to_str(bs.at(0));
	std::cout << "\n";
	std::cout << to_str(As.at(0));

	//do the Fourier-Motzkin-eleminiation and print the result
	fourier_motzkin_step();
	std::cout << "After one step we get\n";
	std::cout << to_str(bs.back());
	std::cout << "\n";
	std::cout << to_str(As.back());

	//print the result
	std::pair <bool, std::vector<double>> result = fourier_motzkin_elimination();
	if (result.first){
		std::cout << to_str(result.second);
	}
	else {
		std::cout << "empty ";
		std::cout << to_str(result.second);
	}
}



/* Old main function
int main()
{	
	std::vector<std::vector<double>> A{
	{1,3.5,2},
	{4,2,1.6},
	{5.3,7,1},
	{4.4,7,3},
	{2.5,3,1}
	};
	std::cout << to_str(A);
}
*/
